WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.930
我们之前已经看过了单连接聚类法是怎样运作的

00:00:03.930 --> 00:00:07.140
我们现在用一点时间 用我们之前看过的数据集

00:00:07.139 --> 00:00:11.070
把它和 K-均值聚类法做个比较

00:00:11.070 --> 00:00:12.380
第一个数据集

00:00:12.380 --> 00:00:16.440
K-均值聚类法似乎更能够把这些均匀分布的数据

00:00:16.440 --> 00:00:20.760
分成三个类

00:00:20.760 --> 00:00:25.050
而单连接聚类法则有一个缺陷

00:00:25.050 --> 00:00:29.910
一个类几乎囊括了整个数据集 仅剩两个非常小的类

00:00:29.910 --> 00:00:33.990
所以 这个案例中 K-均值聚类法更有效

00:00:33.990 --> 00:00:35.700
在双月牙形数据集中

00:00:35.700 --> 00:00:39.250
单连接聚类法能够完美地把两个类分离出来

00:00:39.250 --> 00:00:42.960
这是因为这些数据集彼此靠近

00:00:42.960 --> 00:00:47.520
两个数据集之间有足够的间隙

00:00:47.520 --> 00:00:51.465
所以 这个案例中 单连接聚类法比 K-均值聚类法更有效

00:00:51.465 --> 00:00:57.720
双环形数据集中 同样 单连接聚类法更有效

00:00:57.719 --> 00:00:59.629
完美地将类分离出来

00:00:59.630 --> 00:01:01.020
我们得到一个内环 一个外环

00:01:01.020 --> 00:01:03.945
这两个类恰恰是我们要找的类

00:01:03.945 --> 00:01:05.579
在这个数据集中

00:01:05.579 --> 00:01:07.664
K-均值聚类法更有效

00:01:07.665 --> 00:01:10.965
一个类几乎囊括了所有数据

00:01:10.965 --> 00:01:14.685
所以这个案例中 单连接聚类法不是最佳选择

00:01:14.685 --> 00:01:19.469
这个也不是最佳选择

00:01:19.469 --> 00:01:22.090
但是它能够将这个类分离出来

00:01:22.090 --> 00:01:27.960
但是这个类只有一个点 对我们来说没有多大意义 没多大帮助

00:01:27.959 --> 00:01:34.079
这个案例中 单连接聚类法和 K-均值聚类法效果一样

00:01:34.079 --> 00:01:38.459
但我们能从中额外得到一点信息

00:01:38.459 --> 00:01:39.629
这也是我们之前讨论过的

00:01:39.629 --> 00:01:43.685
就是由此产生的层次或系统树

00:01:43.685 --> 00:01:45.150
我们来看一下

00:01:45.150 --> 00:01:47.070
在这个均匀分布的图中

00:01:47.069 --> 00:01:49.619
我们能看到它的层次是这样的

00:01:49.620 --> 00:01:54.295
但我们从中得不到什么信息

00:01:54.295 --> 00:01:58.125
只能看出 我们没有办法把这个数据集

00:01:58.125 --> 00:02:02.385
分离出清晰明显的类

00:02:02.385 --> 00:02:04.245
在双月牙形数据集中

00:02:04.245 --> 00:02:08.504
我们能看到 这儿有一个类 这儿也有一个类

00:02:08.504 --> 00:02:12.164
这两个类被足够的空隙分离开来

00:02:12.164 --> 00:02:16.609
通过观察这个图表

00:02:16.610 --> 00:02:19.394
我们能发现重要的一点

00:02:19.394 --> 00:02:21.450
如果我们的数据集有三个维度

00:02:21.449 --> 00:02:23.729
四个维度 十个维度 甚至一百个维度呢？

00:02:23.729 --> 00:02:26.849
我们就不能把它绘制成这样的图表

00:02:26.849 --> 00:02:31.180
只能简单地从视觉上判定 它们之间是彼此分离的

00:02:31.180 --> 00:02:33.795
但不管有多少个维度

00:02:33.794 --> 00:02:38.364
我们得到的系统树都能分成这样的维度

00:02:38.365 --> 00:02:44.310
所以 这是种非常有价值的方式 能帮我们对数据集做视觉化处理

00:02:44.310 --> 00:02:47.360
即便是有多个维度的数据集也可以

00:02:47.360 --> 00:02:51.420
针对双环形数据集 我们也能清楚地看到有两个结构

00:02:51.419 --> 00:02:54.489
这两个结构间有充足的间隙

00:02:54.490 --> 00:02:56.260
所以 这个方法非常有用

00:02:56.259 --> 00:02:57.750
我喜欢下面这个例子

00:02:57.750 --> 00:03:00.780
单连接聚类法并不能

00:03:00.780 --> 00:03:02.616
把这个类定义为一个类

00:03:02.616 --> 00:03:03.900
把这个点

00:03:03.900 --> 00:03:06.870
或者这个组群 定义为另一个类

00:03:06.870 --> 00:03:12.090
在这个层次图中 你能看到现在有三个结构

00:03:12.090 --> 00:03:17.133
尽管直接结果显示的并不是我们我们要找的三个类

00:03:17.133 --> 00:03:19.365
但这个系统树图仍然告诉了我们一些信息

00:03:19.365 --> 00:03:21.960
或许你尝试一下

00:03:21.960 --> 00:03:25.365
采用其他的层次聚类法

00:03:25.365 --> 00:03:29.530
你能分离出三个单独的类

00:03:29.530 --> 00:03:31.259
这对这个例子也同样适用

00:03:31.259 --> 00:03:36.000
当我们想要找到这三个类的时候 这是类一

00:03:36.000 --> 00:03:39.175
这是类二 这是类三

00:03:39.175 --> 00:03:40.530
这个聚类方法并不能实现

00:03:40.530 --> 00:03:42.060
但是如果我们看一下系统树图

00:03:42.060 --> 00:03:43.280
很容易发现

00:03:43.280 --> 00:03:45.800
这看起来像一个类

00:03:45.800 --> 00:03:46.890
这儿像是一个类

00:03:46.889 --> 00:03:48.099
这儿也像是一个类

00:03:48.099 --> 00:03:50.655
所以 这个系统树图告诉我们

00:03:50.655 --> 00:03:57.657
可能聚类方法的直接结果有所缺失

00:03:57.657 --> 00:04:00.480
这是一个非常简单的例子

00:04:00.479 --> 00:04:04.869
这三个类之间有足够间隙

00:04:04.870 --> 00:04:07.254
这两个类之间距离更近

00:04:07.254 --> 00:04:11.800
所以 这两个类指的是图中的这两个结构

00:04:11.800 --> 00:04:13.514
所以 这是一个检验方法

00:04:13.514 --> 00:04:17.995
检验单连接聚类法的效果以及这些系统树图的作用

00:04:17.995 --> 00:04:22.019
我们继续看其他的层次聚类法

