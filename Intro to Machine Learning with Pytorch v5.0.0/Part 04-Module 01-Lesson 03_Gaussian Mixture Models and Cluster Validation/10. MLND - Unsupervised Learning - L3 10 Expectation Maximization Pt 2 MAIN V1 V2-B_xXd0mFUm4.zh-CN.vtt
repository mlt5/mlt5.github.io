WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.769
高斯混合模型 (GMM) 期望最大化的算法的第三步

00:00:04.769 --> 00:00:10.251
是将第二步计算得到的结果

00:00:10.252 --> 00:00:15.319
即所有点对所有聚类的隶属度

00:00:15.319 --> 00:00:16.920
具体来说 我们有两个聚类

00:00:16.920 --> 00:00:22.480
用这些来为高斯模型提出新的参数

00:00:22.480 --> 00:00:25.530
所以 第三步的目的在于

00:00:25.530 --> 00:00:28.560
利用第二步的结果作为输入

00:00:28.559 --> 00:00:31.469
来填补这个小表格

00:00:31.469 --> 00:00:33.179
这是针对聚类 A 的

00:00:33.179 --> 00:00:36.750
我们需要新的均值和方差

00:00:36.750 --> 00:00:38.715
我们对聚类 B 做同样的操作

00:00:38.715 --> 00:00:43.935
然后得出这四个值

00:00:43.935 --> 00:00:46.770
我们现在开始

00:00:46.770 --> 00:00:49.710
基于第二步的结果

00:00:49.710 --> 00:00:52.259
聚类 A 新的均值 

00:00:52.259 --> 00:00:56.804
来自于所有这些点的加权平均值

00:00:56.804 --> 00:01:02.144
加权平均值不仅考虑了每个点的参数

00:01:02.145 --> 00:01:05.825
还考虑了它隶属度

00:01:05.825 --> 00:01:07.745
因此 这是聚类 A 的隶属度

00:01:07.745 --> 00:01:09.745
就是这几项

00:01:09.745 --> 00:01:11.189
我们来对其进行计算

00:01:11.189 --> 00:01:13.784
这是第二步得到的结果

00:01:13.784 --> 00:01:18.959
这里列出了所有点对所有聚类的隶属度

00:01:18.959 --> 00:01:21.839
这些数字略有不同

00:01:21.840 --> 00:01:27.155
因为这是考虑了混合系数的正确计算

00:01:27.155 --> 00:01:29.730
这个值是任意的

00:01:29.730 --> 00:01:34.350
我们添加它只是为了展示它的准确性并不总是99％

00:01:34.349 --> 00:01:39.144
它可以是 0 到 1 之间的任何数 比如 55%、40%、30% 等

00:01:39.144 --> 00:01:43.439
这就是我们计算加权平均值的过程

00:01:43.439 --> 00:01:47.564
它基本上是用这个单元格中的值乘以这一行

00:01:47.564 --> 00:01:53.549
包含这两个值的数组或向量

00:01:53.549 --> 00:01:55.064
就是这一项

00:01:55.064 --> 00:01:57.138
然后每一行都进行同样的运算

00:01:57.138 --> 00:02:00.314
将它们加起来 得到这一项

00:02:00.314 --> 00:02:03.599
接着 我们再把这列的值加起来

00:02:03.599 --> 00:02:06.044
这就是被除数

00:02:06.045 --> 00:02:08.340
接着我们进行计算

00:02:08.340 --> 00:02:11.295
得到聚类 A 的新 μ

00:02:11.294 --> 00:02:15.030
我们对聚类 B 进行同样的运算 除了这里

00:02:15.030 --> 00:02:18.405
我们将使用这些点的加权平均值

00:02:18.405 --> 00:02:21.175
其它计算几乎一样

00:02:21.175 --> 00:02:22.875
这样 我们就得到了新值

00:02:22.875 --> 00:02:24.694
要计算新的方差

00:02:24.694 --> 00:02:26.310
我们的方法比较相似

00:02:26.310 --> 00:02:28.229
这里的这一项

00:02:28.229 --> 00:02:35.429
看起来与计算方差的常规算式非常相似

00:02:35.430 --> 00:02:37.830
只是我们在这里要做一个加权

00:02:37.830 --> 00:02:44.070
所以我们在这里乘以对每个聚类的隶属度

00:02:44.069 --> 00:02:48.344
因此 如果插入我们从第二步得到的数据

00:02:48.344 --> 00:02:53.655
我们可以为聚类 A 的新方差获得一个新值

00:02:53.655 --> 00:02:57.150
我们也可以对聚类 B 做同样的处理

00:02:57.150 --> 00:02:59.409
现在 第三步也完成了

00:02:59.409 --> 00:03:02.574
我们有了两个新高斯分布参数

00:03:02.574 --> 00:03:05.375
我们可以把它们与旧的做个比较

00:03:05.375 --> 00:03:07.080
我们看看这里的图表

00:03:07.080 --> 00:03:08.450
这是旧高斯模型

00:03:08.449 --> 00:03:12.491
这是新旧模型的重叠处

00:03:12.491 --> 00:03:15.149
我们可以看到 绿色的模型

00:03:15.150 --> 00:03:18.105
略向右上方移动

00:03:18.104 --> 00:03:20.209
这只是一方面

00:03:20.210 --> 00:03:21.300
如果它不收敛

00:03:21.300 --> 00:03:23.550
我们将继续做这样的 5、10、20

00:03:23.550 --> 00:03:27.510
30 steps like this 
或 30 步

00:03:27.509 --> 00:03:32.909
直到其收敛成一个结果不错的高斯混合模型

00:03:32.909 --> 00:03:37.210
第四步是评估对数似然

00:03:37.210 --> 00:03:42.890
这是所有聚类的对数似然和

00:03:42.889 --> 00:03:46.657
这是与这个聚类有关的混合系数

00:03:46.657 --> 00:03:49.934
这是该聚类的参数下

00:03:49.935 --> 00:03:53.039
每个点的正态分布

00:03:53.039 --> 00:03:57.689
这整个一项称为对数似然

00:03:57.689 --> 00:04:02.264
基本上 这个数字越高

00:04:02.264 --> 00:04:06.884
我们越能确定生成的混合模型可以负责创建数据

00:04:06.884 --> 00:04:11.844
或适合我们有的数据集

00:04:11.844 --> 00:04:16.214
所以 现在的目的是最大化这个值 也就是这一项

00:04:16.214 --> 00:04:21.301
我们通过选择的参数

00:04:21.302 --> 00:04:24.135
包括其混合系数 均值及其方差

00:04:24.134 --> 00:04:27.824
来最大化这个值

00:04:27.824 --> 00:04:30.104
我们选取的参数越好

00:04:30.105 --> 00:04:32.830
这一项的值也就会越大

00:04:32.829 --> 00:04:35.954
然后我们这样做 直到算法收敛

00:04:35.954 --> 00:04:42.714
直到达到最大值 或每一步开始增加一小部分

00:04:42.714 --> 00:04:45.558
这时我们就可以停止运算

00:04:45.559 --> 00:04:47.750
并完成收敛了

00:04:47.750 --> 00:04:51.269
然后选择那些模型作为高斯混合模型的组成部分

00:04:51.269 --> 00:04:55.745
并在它们的基础上聚类

00:04:55.745 --> 00:04:57.540
那么这是进行高斯混合模型聚类

00:04:57.540 --> 00:05:02.615
期望最大化算法的最后一步

00:05:02.615 --> 00:05:05.060
在下一个视频中 我们将看一个视觉性的例子

00:05:05.060 --> 00:05:08.939
在那里我们将可视化第一、二、三步

00:05:08.939 --> 00:05:12.000
以及直到收敛的整个过程

