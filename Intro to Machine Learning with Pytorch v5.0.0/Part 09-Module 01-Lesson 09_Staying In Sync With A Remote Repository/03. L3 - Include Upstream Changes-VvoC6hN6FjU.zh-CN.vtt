WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.835
这是我们的原始仓库

00:00:02.835 --> 00:00:05.129
这是原始仓库的 fork 副本

00:00:05.129 --> 00:00:07.935
这是 fork 副本的克隆

00:00:07.934 --> 00:00:12.949
假设我们想 fork 原始仓库来解决一些错误

00:00:12.949 --> 00:00:18.460
因此我们在本地对 bugfix 分支进行了更改 然后推送至我们的 fork 副本上

00:00:18.460 --> 00:00:20.475
但是当我们在进行这些更改时

00:00:20.475 --> 00:00:22.575
原始项目的维护者

00:00:22.574 --> 00:00:25.480
向仓库中添加了一些自己的 commit

00:00:25.480 --> 00:00:26.969
现在我们的 fork 副本和本地资源的 master 分支

00:00:26.969 --> 00:00:31.769
与原始仓库不同步了

00:00:31.769 --> 00:00:34.588
为了将这些新的更改添加到本地机器上

00:00:34.588 --> 00:00:37.789
我们需要从原始仓库中 fetch 这些更改

00:00:37.789 --> 00:00:42.875
我们已经有我们的远程仓库的链接了 因为在克隆时

00:00:42.875 --> 00:00:45.750
Git 自动为我们创建了一个连接

00:00:45.750 --> 00:00:49.200
并为此连接设定了一个缩略名 origin

00:00:49.200 --> 00:00:54.245
但是我们可以手动设置一个与原始远程仓库之间的连接

00:00:54.244 --> 00:00:57.924
通常我们将其简称为 upstream

00:00:57.924 --> 00:01:02.640
我们加上简称 origin 和 upstream 这样可以轻松地指代它们

00:01:02.640 --> 00:01:07.549
我们已经建立了与原始远程仓库之间的新 upstream 连接

00:01:07.549 --> 00:01:11.920
我们来显示位于本地仓库中的远程分支

00:01:11.920 --> 00:01:15.090
如果我们从 upstream 仓库中获取 commit

00:01:15.090 --> 00:01:20.125
结果将是这两个 commit 和 upstream/master 分支

00:01:20.125 --> 00:01:22.469
这些颜色可能有点误导人

00:01:22.469 --> 00:01:25.950
我们来显示下每个分支与远程仓库的关系

00:01:25.950 --> 00:01:27.400
将本地仓库设为红色

00:01:27.400 --> 00:01:30.900
fork 仓库设为黄色 原始仓库设为蓝色

00:01:30.900 --> 00:01:35.440
bugfix 分支和 master 分支都位于本地仓库中

00:01:35.439 --> 00:01:38.167
并且将它们 Push 到 fork 上了

00:01:38.167 --> 00:01:40.349
Git 知道远程分支在哪

00:01:40.349 --> 00:01:46.424
因此 origin/bugfix 和 origin/master 分支显示在本地仓库中

00:01:46.424 --> 00:01:50.534
原始仓库只有 master 分支

00:01:50.534 --> 00:01:53.535
因为我们获取了 upstream 更改

00:01:53.534 --> 00:01:57.655
因此 upstream/master 分支显示在了本地仓库中

00:01:57.655 --> 00:02:01.465
我们回到按照分支标注颜色的原始显示模式

00:02:01.465 --> 00:02:06.450
如果我们在 master 分支上合并 upstream/master 分支

00:02:06.450 --> 00:02:09.930
我们的 master 分支将执行快进合并

00:02:09.930 --> 00:02:13.875
以合并 commit c 如果我们想合并 bugfix 分支

00:02:13.875 --> 00:02:18.060
这将会创建一个新的合并 commit 并使 master 分支指向它

