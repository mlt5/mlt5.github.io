WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.754
这是一个展示k-means算法工作原理的很好的资源

00:00:04.754 --> 00:00:07.960
让我们看几个例子 

00:00:07.960 --> 00:00:12.144
看看不同的数据集和不同数量的聚类会发生什么

00:00:12.144 --> 00:00:16.559
首先 让我们继续选择一组数据

00:00:16.559 --> 00:00:19.504
也许我们可以选择这个高斯混合

00:00:19.504 --> 00:00:22.399
假设我们在这里放一个形心

00:00:22.399 --> 00:00:25.659
这个算法告诉我们

00:00:25.660 --> 00:00:29.170
在开始时 所有的点都属于这个形心

00:00:29.170 --> 00:00:32.695
也许我们在这儿还有另外一点 还有第三点在这儿

00:00:32.695 --> 00:00:35.000
然后我们开始运行算法

00:00:35.000 --> 00:00:36.744
如果我们点击“Go”按钮

00:00:36.744 --> 00:00:39.640
你可以看到发生的第一件事是

00:00:39.640 --> 00:00:43.035
每个形心都被分配了一定数量的点

00:00:43.034 --> 00:00:45.304
如果我们更新形心

00:00:45.304 --> 00:00:48.104
它们被移到了那个组的中心

00:00:48.104 --> 00:00:51.224
如果我们再次重新分配这些点

00:00:51.225 --> 00:00:54.520
你可以看到 现在这些形心都没有被更新

00:00:54.520 --> 00:00:59.859
这些形心没有移动并且算法

00:00:59.859 --> 00:01:05.539
在那一点上已经停止 因为形心在两次迭代中保持静止

00:01:05.540 --> 00:01:12.250
现在 如果我们重启并且再次选取高斯混合

00:01:12.250 --> 00:01:16.989
但是假设我们有两点在下面也许有一点在上面

00:01:16.989 --> 00:01:22.399
所以我们认为有三个聚类 我们这样运行算法

00:01:22.400 --> 00:01:25.120
首先发生的是所有的形心都被指定了一些点

00:01:25.120 --> 00:01:28.630
然后我们更新它们

00:01:28.629 --> 00:01:31.329
重新分配这些点 然后我们更新形心

00:01:31.329 --> 00:01:35.719
你可以再次看到 运行结束后 我们得到了相同的聚类

00:01:35.719 --> 00:01:40.150
这应该能让你对k-means算法寻找点的最近形心的

00:01:40.150 --> 00:01:45.410
幕后工作有一些直觉 它首先找到离形心最近的点

00:01:45.409 --> 00:01:49.989
更新形心并观察新位置上最近的点

00:01:49.989 --> 00:01:54.119
更新形心直到形心不再移动为止

00:01:54.120 --> 00:01:58.230
但让我们看看如果出了问题会发生什么

00:01:58.230 --> 00:02:01.180
让我们再做一次高斯混合模型

00:02:01.180 --> 00:02:03.180
我们有两个这样的形心

00:02:03.180 --> 00:02:10.310
我们执行聚类算法直到它完成 结果是这样的

00:02:10.310 --> 00:02:15.090
但如果我们重新启动  我们的数据完全相同

00:02:15.090 --> 00:02:17.365
也许我们在这里放了一个形心

00:02:17.365 --> 00:02:22.335
我们在下面加一个形心 在上面加一个形心

00:02:22.335 --> 00:02:27.705
现在运行算法显示我们得到了一个不同的分组

00:02:27.705 --> 00:02:30.630
并不是每次结束时的分组都是一样的

00:02:30.629 --> 00:02:34.085
而那一个分组实际上是最好的

00:02:34.085 --> 00:02:37.270
这是我们将在下一个页面中探讨的问题

