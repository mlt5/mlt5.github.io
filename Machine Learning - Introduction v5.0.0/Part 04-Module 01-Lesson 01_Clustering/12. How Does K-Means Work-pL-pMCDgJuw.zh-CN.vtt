WEBVTT
Kind: captions
Language: zh-CN

00:00:03.830 --> 00:00:08.655
你现在已经看到了与k-means相关的主要思想和使用方法

00:00:08.654 --> 00:00:12.389
从将聚类理解为一种非监督学习方法

00:00:12.390 --> 00:00:14.690
到选择合适数量的聚类

00:00:14.689 --> 00:00:17.640
但是我们如何实际建立一个算法

00:00:17.640 --> 00:00:21.425
找出这些聚类的中心在哪里？

00:00:21.425 --> 00:00:24.275
让我们仔细看看这是如何工作的

00:00:24.274 --> 00:00:26.570
让我们以这个图为例

00:00:26.570 --> 00:00:30.304
逐步了解k-means算法的工作原理

00:00:30.304 --> 00:00:31.739
当我们开始的时候

00:00:31.739 --> 00:00:35.234
我们只有一个没有分类的集群

00:00:35.234 --> 00:00:39.629
我们通过在图上随机放置k个点开始k-means算法

00:00:39.630 --> 00:00:43.020
其中k是结束时我们期望的聚类的数量

00:00:43.020 --> 00:00:46.210
我们把这些k点都称为形心

00:00:46.210 --> 00:00:49.049
它们只是随机地放在数据中

00:00:49.049 --> 00:00:50.644
所以我们需要移动它们

00:00:50.645 --> 00:00:55.835
我们的方法是将数据集中的每个点指定给最近的形心

00:00:55.835 --> 00:00:59.299
现在我们知道了每个点属于哪个组

00:00:59.299 --> 00:01:01.924
我们将形心移到这些点的中心

00:01:01.924 --> 00:01:04.189
一旦形心移动

00:01:04.189 --> 00:01:07.609
有些点可能更接近另一组的形心

00:01:07.609 --> 00:01:12.500
现在 我们将重新计算从各点到每个形心的距离

00:01:12.500 --> 00:01:15.819
并再次将每个点指定给最近的形心

00:01:15.819 --> 00:01:18.125
通过这个新的点分配

00:01:18.125 --> 00:01:20.379
我们将再次想将形心移动到

00:01:20.379 --> 00:01:22.984
分配给它的点组的中间

00:01:22.984 --> 00:01:27.379
这个过程将一直持续 直到形心不再移动为止

00:01:27.379 --> 00:01:29.039
我们的搜索到此结束

00:01:29.040 --> 00:01:33.840
这里我们得到了k组聚类作为最终结果

