{
  "data": {
    "lesson": {
      "id": 571220,
      "key": "6ab50b2b-0a93-489b-a142-3b84a151e9d9",
      "title": "Multivariate Exploration of Data",
      "semantic_type": "Lesson",
      "is_public": true,
      "version": "1.0.0",
      "locale": "en-us",
      "summary": "In this lesson, see how you can use matplotlib and seaborn to visualize relationships and interactions between three or more variables.",
      "lesson_type": "Classroom",
      "display_workspace_project_only": null,
      "resources": {
        "files": [
          {
            "name": "Videos Zip File",
            "uri": "https://zips.udacity-data.com/6ab50b2b-0a93-489b-a142-3b84a151e9d9/571220/1544196822452/Multivariate+Exploration+of+Data+Videos.zip"
          },
          {
            "name": "Transcripts Zip File",
            "uri": "https://zips.udacity-data.com/6ab50b2b-0a93-489b-a142-3b84a151e9d9/571220/1544196818474/Multivariate+Exploration+of+Data+Subtitles.zip"
          },
          {
            "name": "pokemon.csv",
            "uri": "https://video.udacity-data.com/topher/2018/April/5ac2906c_pokemon/pokemon.csv"
          },
          {
            "name": "fuel_econ.csv",
            "uri": "https://video.udacity-data.com/topher/2018/April/5ac2907f_fuel-econ/fuel-econ.csv"
          }
        ],
        "google_plus_link": null,
        "career_resource_center_link": null,
        "coaching_appointments_link": null,
        "office_hours_link": null,
        "aws_provisioning_link": null
      },
      "project": null,
      "lab": null,
      "concepts": [
        {
          "id": 572370,
          "key": "88ec8c8c-5c72-4c88-8d3d-63134ea7fb49",
          "title": "Introduction",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "88ec8c8c-5c72-4c88-8d3d-63134ea7fb49",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 572371,
              "key": "3eeb77c8-1e44-455c-9762-af8fe02e4a17",
              "title": "L5 011 Intro V3",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "ckylQMBXB10",
                "china_cdn_id": "ckylQMBXB10.mp4"
              }
            }
          ]
        },
        {
          "id": 572372,
          "key": "0f3b9898-d917-4cc8-a688-bef35d8566fb",
          "title": "Non-Positional Encodings for Third Variables",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "0f3b9898-d917-4cc8-a688-bef35d8566fb",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 572373,
              "key": "04408ee3-2b18-4169-88ad-4017e153659b",
              "title": "L5 021 Non Positional Encodings For Third Variables V1",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "D91mm-qaDkk",
                "china_cdn_id": "D91mm-qaDkk.mp4"
              }
            },
            {
              "id": 572429,
              "key": "3ff8936e-5a62-4397-b272-e2dc903b4e23",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<hr>",
              "instructor_notes": ""
            },
            {
              "id": 572374,
              "key": "1af59d0a-800d-402c-b522-fc7dc764ba0c",
              "title": "DataVis L5C02 V3",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "bgDNMfG9Gfs",
                "china_cdn_id": "bgDNMfG9Gfs.mp4"
              }
            },
            {
              "id": 572428,
              "key": "0c0a9ff7-7f90-4b16-86f6-cfcdba3dd4b1",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<hr>\n## Non-Positional Encodings for Third Variables\n\nThere are four major cases to consider when we want to plot three variables together:\n- three numeric variables\n- two numeric variables and one categorical variable\n- one numeric variable and two categorical variables\n- three categorical variables\n\nIf we have at least two numeric variables, as in the first two cases, one common method for depicting the data is by using a scatterplot to encode two of the numeric variables, then using a non-positional encoding on the points to convey the value on the third variable, whether numeric or categorical. (You will see additional techniques later in the lesson that can also be applied to the other two cases, i.e. where we have at least two categorical variables.)\n\nThree main non-positional encodings stand out: shape, size, and color. For Matplotlib and Seaborn, color is the easiest of these three encodings to apply for a third variable. Color can be used to encode both qualitative and quantitative data, with different types of color palettes used for different use cases. Because of how broadly color can be used, a dedicated discussion of color and its use in Matplotlib and Seaborn will be deferred to the next page in the lesson.\n\n## Encoding via Shape\n\nShape is a good encoding for categorical variables, using one shape for each level of the categorical variable. Unfortunately, there is no built-in way to automatically assign different shapes in a single call of the `scatter` or `regplot` function. Instead, we need to write a loop to call our plotting function multiple times, isolating data points by categorical level and setting a different \"marker\" argument value for each one.\n```python\ncat_markers = [['A', 'o'],\n               ['B', 's']]\n\nfor cat, marker in cat_markers:\n    df_cat = df[df['cat_var1'] == cat]\n    plt.scatter(data = df_cat, x = 'num_var1', y = 'num_var2', marker = marker)\nplt.legend(['A','B'])\n```\nThe 'o' string specifies circular markers for members of category 'A', while the 's' string specifies square markers for members of category 'B'. The [`legend`](https://matplotlib.org/api/_as_gen/matplotlib.pyplot.legend.html) function adds a legend to the plot, with one marker for every `scatter` call made. The function argument sets the labels for those points.\n\n(Documentation: [matplotlib built-in markers](https://matplotlib.org/api/markers_api.html), [marker reference example](https://matplotlib.org/examples/lines_bars_and_markers/marker_reference.html))",
              "instructor_notes": ""
            },
            {
              "id": 573484,
              "key": "53bd8420-ed29-4368-969e-3c001599094b",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5abaae7b_l5-c02-encodings1/l5-c02-encodings1.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/53bd8420-ed29-4368-969e-3c001599094b",
              "caption": "",
              "alt": "",
              "width": 432,
              "height": 288,
              "instructor_notes": null
            },
            {
              "id": 573485,
              "key": "59cda7ac-e8b1-4190-8e37-dc44cfcee0ec",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "From the positional encodings in the plot, you can see that there is a modest positive relationship between the two numeric variables. Adding the categorical variable via shape encoding, we can see that points of category 'A' tend to be smaller than those of category 'B' in terms of the numeric x-variable (\"num_var1\"). Neither category seems to have an advantage in terms of variability or value for the numeric y-variable (\"num_var2\").\n\nNote that the two categories have automatically been double-encoded with different colors, in addition to the explicitly specified markers. If we wanted the points to have the same color as well, we could do that through the \"c\" parameter in `scatter` or \"color\" in `regplot`. A small example of where this is useful will be seen in the next section.\n\n## Encoding via Size\n\nPoint size is a good encoding for numeric variables. Usually, we want the numeric values to be proportional to the area of the point markers; this is the default functionality of the \"s\" parameter in `scatter`. (You need to refer to \"s\" through a dictionary assigned to the \"scatter_kws\" parameter when working with `regplot`.)\n```python\nplt.scatter(data = df, x = 'num_var1', y = 'num_var2', s = 'num_var3')\n\n# dummy series for adding legend\nsizes = [20, 35, 50]\nbase_color = sb.color_palette()[0]\nlegend_obj = []\nfor s in sizes:\n    legend_obj.append(plt.scatter([], [], s = s, color = base_color))\nplt.legend(legend_obj, sizes)\n```\nWhile the creation of the plot is easier with size, we need to put in extra leg work to create a legend. Since, as noted above, `legend` will only create one legend entry per plot function call, we need to create additional dummy `scatter` objects with reference sizes to create the plot. The color is fixed so that all of the legend entries have the same color, and two arguments are provided to the `legend` function: the list of plotting objects to depict in the legend, and their labels.",
              "instructor_notes": ""
            },
            {
              "id": 573488,
              "key": "845925a4-1004-411e-a53d-cdbbb09a9242",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5ababf13_l5-c02-encodings2/l5-c02-encodings2.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/845925a4-1004-411e-a53d-cdbbb09a9242",
              "caption": "",
              "alt": "",
              "width": 432,
              "height": 288,
              "instructor_notes": null
            },
            {
              "id": 573489,
              "key": "e89119cb-50bd-4092-96e2-26fbc7715b36",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The size encoding for the third numeric variable (\"num_var3\") shows that its values are largest in the 'middle' of the distribution of values, and smaller on the upper and bottom edges. It is also clear that size is much less precise an encoding than position, so it is better used to make general, qualitative judgments than precise judgments.\n\nIn the case of the example, the data was also scaled in a way that the marker sizes made sense as given. You might need to apply a scaling factor (e.g., multiplying or dividing all values by 2) or shift in order to make the size encoding interpretable. In particular, if the values in your third numeric variable include negative values, then you might want to choose a color encoding instead.\n\n## A Warning on Combining Encodings\n\nIt might seem plausible to combine both size and shape encodings into the same plot, to depict the trend in four variables at once. Technically, this may be true, but there are some cautions to be taken with this approach. One surface issue is that the code to depict the plot and a reasonable legend gets complicated. A more important issue is that point areas won't all be the same even with the same value, depending on the shape of the marker:\n```python\nplt.figure(figsize = [5,5])\n\ncommon_size = 2500\nplt.scatter([0],[1], marker = 's', s = common_size)\nplt.scatter([1],[1], marker = '^', s = common_size)\nplt.scatter([0],[0], marker = 'o', s = common_size)\nplt.scatter([1],[0], marker = 'X', s = common_size)\n\n# a little bit of aesthetic cleaning\nplt.xlim(-0.5,1.5)\nplt.xticks([])\nplt.ylim(-0.5,1.5)\nplt.yticks([])\n```",
              "instructor_notes": ""
            },
            {
              "id": 573490,
              "key": "9ecb72b6-1ffd-409f-ba6d-68c3700f2d8e",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5abac650_l5-c02-encodings3/l5-c02-encodings3.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/9ecb72b6-1ffd-409f-ba6d-68c3700f2d8e",
              "caption": "",
              "alt": "",
              "width": 360,
              "height": 360,
              "instructor_notes": null
            },
            {
              "id": 573492,
              "key": "f675febd-c9e7-43d8-b565-0e4fbc795fc5",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Despite having the same \"s\" values, the triangle, circle, and X markers all look smaller (have a smaller area) than the square. Perhaps this isn't a major concern, considering that size is better used as a qualitative measure for exploration. But it's still something to consider. A little more discussion of the number of variables that can be reasonably packed into a plot can be found later in the lesson (\"How much is too much?\").",
              "instructor_notes": ""
            },
            {
              "id": 578219,
              "key": "36e99082-aae0-4123-afb8-8059cc766d8d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Further Reading\n\n- Bloomberg: [Tracking Super Bowl Ticket Prices](https://www.bloomberg.com/graphics/infographics/tracking-super-bowl-ticket-prices.html) - This visualization shows an interesting encoding for a third variable: connecting points by a line to show the changes in the two axis values across time. A different marker at each end of the path shows the starting point and the end point.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 572383,
          "key": "ba31fc66-d628-4125-a937-2b3e7974a696",
          "title": "Color Palettes",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "ba31fc66-d628-4125-a937-2b3e7974a696",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 572384,
              "key": "2255c9fe-acdc-483b-8c08-dae0ff2c5db9",
              "title": "L5 031 Color Palettes V1",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "nirOTWkuiSM",
                "china_cdn_id": "nirOTWkuiSM.mp4"
              }
            },
            {
              "id": 578118,
              "key": "afc42689-afd2-4f17-9e61-46b822defa7f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<hr>",
              "instructor_notes": ""
            },
            {
              "id": 572385,
              "key": "f3b22033-c863-4433-ab80-f547e52db25a",
              "title": "DataVis L5C03 V2",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "iokI7HrxeNc",
                "china_cdn_id": "iokI7HrxeNc.mp4"
              }
            },
            {
              "id": 573503,
              "key": "98e00d1b-56d0-45ec-a55c-662828146822",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<hr>\n## Encoding via Color\n\nColor is a very common encoding for variables, for both qualitative and quantitative variables. You've already seen this employed in previous lessons where position could not be used to encode a value: color for category in a clustered bar chart, and color for count in a heat map (both as a 2-d histogram and as a 2-d bar chart). Here, we'll look at how to employ color in scatterplots, as well as discuss more about color palette choices depending on the type of data you have.\n\nIf you have a qualitative variable, you can set different colors for different levels of a categorical variable through the \"hue\" parameter on seaborn's [**FacetGrid**](https://seaborn.pydata.org/generated/seaborn.FacetGrid.html) class.\n```python\ng = sb.FacetGrid(data = df, hue = 'cat_var1', size = 5)\ng.map(plt.scatter, 'num_var1', 'num_var2')\ng.add_legend()\n```",
              "instructor_notes": ""
            },
            {
              "id": 578072,
              "key": "7ae55411-b389-4c5c-b3bc-1aebfc24103f",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5abbc9e1_l5-c03-color1/l5-c03-color1.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/7ae55411-b389-4c5c-b3bc-1aebfc24103f",
              "caption": "",
              "alt": "",
              "width": 411,
              "height": 360,
              "instructor_notes": null
            },
            {
              "id": 578111,
              "key": "ca5e83c1-6408-45c8-bf71-5fb8bf09a9c5",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "We get a plot that is similar to what was observed in the previous page: points of category A tend to be smaller than category B on \"num_var1\" for the x-axis, and there doesn't appear to be any interaction with \"num_var2\" as depicted on the y-axis.\n\nFor quantitative variables, we should not take the same approach, since **FacetGrid** expects any variable input for subsetting to be categorical. Instead, we can set color based on numeric value in the `scatter` function through the \"c\" parameter, much like how we set up marker sizes through \"s\". (Unlike with size, we don't have an easy way of setting color by numeric value through `regplot` due to how its \"color\" argument is set up.)\n\n```python\nplt.scatter(data = df, x = 'num_var1', y = 'num_var2', c = 'num_var3')\nplt.colorbar()\n```",
              "instructor_notes": ""
            },
            {
              "id": 578112,
              "key": "c222ad46-90d2-4048-bc6e-c82a2c1c6f89",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5abbe123_l5-c03-color2/l5-c03-color2.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/c222ad46-90d2-4048-bc6e-c82a2c1c6f89",
              "caption": "",
              "alt": "",
              "width": 432,
              "height": 288,
              "instructor_notes": null
            },
            {
              "id": 578114,
              "key": "86441c67-42d3-47fa-a594-c0f57ca6aa9a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "As we saw before, when points lie further away from the central line through the data, the value on the third variable decreases. Compared to the size encoding, we have a more precise idea of value on the third variable, though certainly not as precise as positional encodings.\n\n## Color Palettes\n\nDepending on the type of data you have, you may want to change the type of color palette that you use to depict your data. There are three major classes of color palette to consider: qualitative, sequential, and diverging.\n\n**Qualitative** palettes are built for nominal-type data. This is the palette class taken by the default palette.\n\n```python\nsb.palplot(sb.color_palette(n_colors=9))\n```\n(Documentation: seaborn [`palplot`](https://seaborn.pydata.org/generated/seaborn.palplot.html), [`color_palette`](https://seaborn.pydata.org/generated/seaborn.color_palette.html))",
              "instructor_notes": ""
            },
            {
              "id": 578119,
              "key": "92c17e50-cd6a-4c12-9132-426f4e1bfd06",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5abbe740_l5-c03-color3/l5-c03-color3.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/92c17e50-cd6a-4c12-9132-426f4e1bfd06",
              "caption": "",
              "alt": "",
              "width": 648,
              "height": 72,
              "instructor_notes": null
            },
            {
              "id": 578120,
              "key": "8b704233-ba36-40a2-8055-2811f348b477",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "In a qualitative palette, consecutive color values are distinct so that there is no inherent ordering of levels implied. Colors in a good qualitative palette should also try and avoid drastic changes in brightness and saturation that would cause a reader to interpret one category as being more important than the others - unless that emphasis is deliberate and purposeful.\n\nFor other types of data (ordinal and numeric), a choice may need to be made between a sequential scale and a diverging scale. In a **sequential** palette, consecutive color values should follow each other systematically. Typically, this follows a light-to-dark trend across a single or small range of hues, where light colors indicate low values and dark colors indicate high values. The default sequential color map, \"viridis\", takes the opposite approach, with dark colors indicating low values, and light values indicating high.\n```python\nsb.palplot(sb.color_palette('viridis', 9))\n```",
              "instructor_notes": ""
            },
            {
              "id": 578128,
              "key": "20200756-bd3b-4b64-a586-df431f894ecd",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5abbf5e5_l5-c03-color4/l5-c03-color4.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/20200756-bd3b-4b64-a586-df431f894ecd",
              "caption": "",
              "alt": "",
              "width": 648,
              "height": 72,
              "instructor_notes": null
            },
            {
              "id": 578129,
              "key": "1e493ca6-e993-461e-8e4b-546b1f5a379c",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Most of the time, a sequential palette will depict ordinal or numeric data just fine. However, if there is a meaningful zero or center value for the variable, you may want to consider using a **diverging** palette. In a diverging palette, two sequential palettes with different hues are put back to back, with a common color (usually white or gray) connecting them. One hue indicates values greater than the center point, while the other indicates values smaller than the center.\n```python\nsb.palplot(sb.color_palette('vlag', 9))\n```",
              "instructor_notes": ""
            },
            {
              "id": 578130,
              "key": "d07b9408-2ffb-4b08-8a3b-d3edf677eb31",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5abbf873_l5-c03-color5/l5-c03-color5.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/d07b9408-2ffb-4b08-8a3b-d3edf677eb31",
              "caption": "",
              "alt": "",
              "width": 648,
              "height": 72,
              "instructor_notes": null
            },
            {
              "id": 578132,
              "key": "ae23b5b7-fa22-4105-9a80-c7528b91c10a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Selecting Color Palettes\n\nIf you want to change the color map for your plot, the easiest way of doing so is by using one of the built-ins from Matplotlib or Seaborn. [This part](https://matplotlib.org/api/pyplot_summary.html#colors-in-matplotlib) of the Matplotlib documentation has a list of strings that can be understood for color mappings. For most of your purposes, stick with the palettes noted in the top few tables as built-in for Matplotlib ('viridis', etc.) or from ColorBrewer; the remaining palettes may not be as perceptually consistent. Seaborn also adds in a number of its own palettes:\n\n- **Qualitative** (all up to 6 colors): 'deep', 'pastel', 'dark', 'muted', 'bright', 'colorblind'\n- **Sequential**: 'rocket' (white-orange-red-purple-black), 'mako' (mint-green-blue-purple-black)\n- **Diverging**: 'vlag' (blue-white-red), 'icefire' (blue-black-orange)\n\nFor all of these strings, appending '_r' reverses the palette, which is useful if a sequential or diverging palette is rendered counter to your expectations.\n\nA color palette can be set in **FacetGrid** through the \"palette\" parameter, and in `scatter` through the \"cmap\" parameter.\n```python\ng = sb.FacetGrid(data = df, hue = 'cat_var1', size = 5,\n                 palette = 'colorblind')\ng.map(plt.scatter, 'num_var1', 'num_var2')\ng.add_legend()\n```",
              "instructor_notes": ""
            },
            {
              "id": 578133,
              "key": "0f55c653-0ab4-4914-a2b5-122fad14491c",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5abbfe0a_l5-c03-color6/l5-c03-color6.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/0f55c653-0ab4-4914-a2b5-122fad14491c",
              "caption": "",
              "alt": "",
              "width": 411,
              "height": 360,
              "instructor_notes": null
            },
            {
              "id": 578134,
              "key": "87dee3fd-2965-48e1-8282-54c8a836c666",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "```python\nplt.scatter(data = df, x = 'num_var1', y = 'num_var2', c = 'num_var3',\n            cmap = 'mako_r')\nplt.colorbar()\n```",
              "instructor_notes": ""
            },
            {
              "id": 578135,
              "key": "16ef5dde-2a13-406a-b53a-b52e574bd2c3",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5abbfe28_l5-c03-color7/l5-c03-color7.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/16ef5dde-2a13-406a-b53a-b52e574bd2c3",
              "caption": "",
              "alt": "",
              "width": 432,
              "height": 288,
              "instructor_notes": null
            },
            {
              "id": 578345,
              "key": "75881323-f05c-445b-ba9e-9ee327820c27",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "When using a diverging color palette, you will likely need to specify the \"vmin\" and \"vmax\" parameters in order to have the neutral point in the palette meet the center point in the scale. Alternatively, solutions that create a different normalization function like the one posted in [this Stack Overflow thread](https://stackoverflow.com/questions/20144529/shifted-colorbar-matplotlib) can be used for finer control over the color map. Diverging color scales are common enough for the `heatmap` type that there is a \"center\" parameter for setting the central value. You'll see a demonstration of this later in the lesson (\"Plot Matrices\").",
              "instructor_notes": ""
            },
            {
              "id": 578139,
              "key": "e94c4562-e7b0-4cb7-bd4b-cd813b989b2c",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Warnings on Color\n\nThere are a couple of things to be aware of in general, when working with color. First of all, try and consider color blindness when selecting color for your plots. You don't want your visualization to shut out the 8% of the population that have some kind of color vision deficiency. Fortunately, the built-in color palettes highlighted in the previous section should minimize these concerns. If you use a different, or custom palette, it might be worth checking your visualization's interpretability through a color blindness sim like [this one](http://www.color-blindness.com/coblis-color-blindness-simulator/).\n\nSecondly, you want to be aware of the effect of transparency and overlap on interpretability. If points of different color on a qualitative scale overlap, the result may be a third color that cannot be matched to something in the palette. If multiple points on a quantitative scale overlap, then the result may be a value that does not actually exist in the data. To be safe here, avoid or minimize transparency in plots with color. You may need to plot only a sample of your points in order to make sure that the effect of the third variable is clearly visible.\n\n```python\nplt.figure(figsize = [5,5])\n\n# left: qualitative points\nplt.scatter(0,0.5,s = 1e4, c = sb.color_palette()[0], alpha = 0.5)\nplt.scatter(0,-0.5,s = 1e4, c = sb.color_palette()[1], alpha = 0.5)\n\n# right: quantitative points\nplt.scatter(1,0.5,s = 1e4, c = sb.color_palette('Blues')[2], alpha = 0.5)\nplt.scatter(1,-0.5,s = 1e4, c = sb.color_palette('Blues')[4], alpha = 0.5)\n\n# set axes for point overlap\nplt.xlim(-0.5,1.5)\nplt.ylim(-3.5,3.5)\nplt.xticks([])\nplt.yticks([])\n```",
              "instructor_notes": ""
            },
            {
              "id": 578142,
              "key": "7587cdab-fba8-46eb-8452-4ed0ef39fdce",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5abc077b_l5-c03-color8/l5-c03-color8.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/7587cdab-fba8-46eb-8452-4ed0ef39fdce",
              "caption": "",
              "alt": "",
              "width": 360,
              "height": 360,
              "instructor_notes": null
            },
            {
              "id": 578121,
              "key": "c6a56941-57cf-4b79-a4d4-22e909d456b3",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Further Reading\n\n- Matplotlib tutorial: [Colormaps in Matplotlib](https://matplotlib.org/tutorials/colors/colormaps.html)\n- Seaborn tutorial: [Choosing color palettes](https://seaborn.pydata.org/tutorial/color_palettes.html)\n- Eager Eyes: [How The Rainbow Color Map Misleads](https://eagereyes.org/basics/rainbow-color-map) - seaborn will refuse to accept the 'jet' palette string, which corresponds with a rainbow-colored palette that covers the entire range of hues. This, and the next link, will tell you why it's been forbidden.\n- Agile Scientific: [No more rainbows!](https://agilescientific.com/blog/2017/12/14/no-more-rainbows)\n- Datawrapper: [How to Choose a Color Palette for Choropleth Maps](https://blog.datawrapper.de/how-to-choose-a-color-palette-for-choropleth-maps/) - Though this article discusses color in the context of maps and for a specific software tool, it's a useful reference if you want to create a non-linear normalization function.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 572386,
          "key": "e0cc6fa7-463d-4a08-b68c-8a6d4d1da07b",
          "title": "Encodings Practice",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "e0cc6fa7-463d-4a08-b68c-8a6d4d1da07b",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 593801,
              "key": "c335b933-f5f5-40d1-981f-d8ed7a6950de",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "viewdf5cb869",
              "pool_id": "jupyter",
              "view_id": "df5cb869-fd08-4271-989f-3b223281afbd",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Encodings_Practice.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 572387,
          "key": "d64700c6-2de9-4183-a9f9-2ba7779602b9",
          "title": "Faceting in Two Directions",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "d64700c6-2de9-4183-a9f9-2ba7779602b9",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 572388,
              "key": "0daa15f7-27ac-4a86-99b0-7c00e1c93a22",
              "title": "L5 051 Faceting In Two Directions V3",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "lz5dcoTcV2o",
                "china_cdn_id": "lz5dcoTcV2o.mp4"
              }
            },
            {
              "id": 578143,
              "key": "e0d148b4-f79f-4988-8bbb-dff11699394b",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<hr>",
              "instructor_notes": ""
            },
            {
              "id": 572389,
              "key": "306ea226-114a-4d63-a11d-782d2494d931",
              "title": "DataVis L5C05 V1",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "v19gCP4TvwE",
                "china_cdn_id": "v19gCP4TvwE.mp4"
              }
            },
            {
              "id": 578145,
              "key": "c4253b24-4535-464c-b742-a2a19e7db74a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<hr>\n## Faceting for Multivariate Data\n\nIn the previous lesson, you saw how **FacetGrid** could be used to subset your dataset across levels of a categorical variable, and then create one plot for each subset. Where the faceted plots demonstrated were univariate before, you can actually use any plot type, allowing you to facet bivariate plots to create a multivariate visualization.\n```python\ng = sb.FacetGrid(data = df, col = 'cat_var1', size = 4)\ng.map(sb.boxplot, 'cat_var2', 'num_var2')\n```",
              "instructor_notes": ""
            },
            {
              "id": 578216,
              "key": "ee839161-390e-4493-84aa-b03849d59dbe",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5abc34a1_l5-c05-faceting1/l5-c05-faceting1.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/ee839161-390e-4493-84aa-b03849d59dbe",
              "caption": "",
              "alt": "",
              "width": 576,
              "height": 288,
              "instructor_notes": null
            },
            {
              "id": 578217,
              "key": "d7165415-8a6b-4164-b112-c84b08ed54b3",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The faceted box plot suggests a slight interaction between the two categorical variables, where, in level B of \"cat_var1\", the level of \"cat_var2\" seems to be have a larger effect on the value of \"num_var2\", compared to the trend within \"cat_var1\" level A.\n\n**FacetGrid** also allows for faceting a variable not just by columns, but also by rows. We can set one categorical variable on each of the two facet axes for one additional method of depicting multivariate trends.\n```python\ng = sb.FacetGrid(data = df, col = 'cat_var2', row = 'cat_var1', size = 2.5,\n                margin_titles = True)\ng.map(plt.scatter, 'num_var1', 'num_var2')\n```\nSetting `margin_titles = True` means that instead of each facet being labeled with the combination of row and column variable, labels are placed separately on the top and right margins of the facet grid. This is a boon, since the default plot titles are usually too long.",
              "instructor_notes": ""
            },
            {
              "id": 578218,
              "key": "adf9a4aa-b987-44ed-92a2-3bc6a23e75b2",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5abc3ac4_l5-c05-faceting2/l5-c05-faceting2.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/adf9a4aa-b987-44ed-92a2-3bc6a23e75b2",
              "caption": "",
              "alt": "",
              "width": 540,
              "height": 360,
              "instructor_notes": null
            }
          ]
        },
        {
          "id": 572390,
          "key": "c8f7618a-637d-427a-b8df-83a0bc45a4cf",
          "title": "Other Adaptations of Bivariate Plots",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "c8f7618a-637d-427a-b8df-83a0bc45a4cf",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 572391,
              "key": "8665b536-6711-4340-9b9d-98ddbf0d79b8",
              "title": "L5 061 Other Adaptations Of Bivariate Plots V3",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "qanSZttNzFM",
                "china_cdn_id": "qanSZttNzFM.mp4"
              }
            },
            {
              "id": 578220,
              "key": "bf87b1a2-b1fa-4dbb-9e2b-5d7d83c4b76c",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<hr>",
              "instructor_notes": ""
            },
            {
              "id": 572392,
              "key": "64ca5a79-3c03-435c-8d7b-efd34c41de3d",
              "title": "DataVis L5C06 V2",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "BzzTlWHMyV0",
                "china_cdn_id": "BzzTlWHMyV0.mp4"
              }
            },
            {
              "id": 578221,
              "key": "f8c66bb2-437e-4964-8d40-32b2f7c3ec43",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<hr>\n## Other Adaptations of Bivariate Plots\n\nYou also saw one other way of expanding univariate plots into bivariate plots in the previous lesson: substituting count on a bar chart or histogram for the mean, median, or some other statistic of a second variable. This adaptation can also be done for bivariate plots like the heat map, clustered bar chart, and line plot, to allow them to depict multivariate relationships.\n\nIf we want to depict the mean of a third variable in a **2-d histogram**, we need to change the weights of points in the `hist2d` function similar to how we changed the weights in the 1-d histogram.\n```python\nxbin_edges = np.arange(0.25, df['num_var1'].max()+0.5, 0.5)\nybin_edges = np.arange(7,    df['num_var2'].max()+0.5, 0.5)\n\n# count number of points in each bin\nxbin_idxs = pd.cut(df['num_var1'], xbin_edges, right = False,\n                    include_lowest = True, labels = False).astype(int)\nybin_idxs = pd.cut(df['num_var2'], ybin_edges, right = False,\n                    include_lowest = True, labels = False).astype(int)\n\npts_per_bin = df.groupby([xbin_idxs, ybin_idxs]).size()\npts_per_bin = pts_per_bin.reset_index()\npts_per_bin = pts_per_bin.pivot(index = 'num_var1', columns = 'num_var2').values\n\nz_wts = df['num_var3'] / pts_per_bin[xbin_idxs, ybin_idxs]\n\n# plot the data using the calculated weights\nplt.hist2d(data = df, x = 'num_var1', y = 'num_var2', weights = z_wts,\n           bins = [xbin_edges, ybin_edges], cmap = 'viridis_r', cmin = 0.5);\nplt.xlabel('num_var1')\nplt.ylabel('num_var2');\nplt.colorbar(label = 'mean(num_var3)');\n```",
              "instructor_notes": ""
            },
            {
              "id": 578234,
              "key": "e8c7f848-6133-4ca8-90f4-4cabf7a1e6ae",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5abc4dcf_l5-c06-adaptations1/l5-c06-adaptations1.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/e8c7f848-6133-4ca8-90f4-4cabf7a1e6ae",
              "caption": "",
              "alt": "",
              "width": 432,
              "height": 288,
              "instructor_notes": null
            },
            {
              "id": 578230,
              "key": "173bfc0d-0c27-4c04-ac34-9a336acceb2a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Considering how few data points there are in the example, and how cleanly the third variable is distributed, the adapted heat map is a bit excessive in terms of work. The low level of point overlap observed earlier means that the scatterplot with color or size encoding was sufficient for depicting the data. You'll be more likely to use the heat map if there is a lot of data to be aggregated.\n\nThe code for the **2-d bar chart** doesn't actually change much. The actual `heatmap` call is still the same, only the aggregation of values changes. Instead of taking `size` after the `groupby` operation, we compute the `mean` across dataframe columns and isolate the column of interest.\n```python\ncat_means = df.groupby(['cat_var1', 'cat_var2']).mean()['num_var2']\ncat_means = cat_means.reset_index(name = 'num_var2_avg')\ncat_means = cat_means.pivot(index = 'cat_var2', columns = 'cat_var1',\n                            values = 'num_var2_avg')\nsb.heatmap(cat_means, annot = True, fmt = '.3f',\n           cbar_kws = {'label' : 'mean(num_var2)'})\n```\nNote how the \"cbar_kws\" provides an additional argument to the colorbar component of the heat map call.",
              "instructor_notes": ""
            },
            {
              "id": 578253,
              "key": "94dd73eb-52f5-4b93-a205-9cef6b6772fa",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5abc952c_l5-c06-adaptations2/l5-c06-adaptations2.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/94dd73eb-52f5-4b93-a205-9cef6b6772fa",
              "caption": "",
              "alt": "",
              "width": 432,
              "height": 288,
              "instructor_notes": null
            },
            {
              "id": 578255,
              "key": "102fc6e6-f5b4-4b00-8945-d7c1fcb75b61",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "An alternative approach for two categorical variables and one numeric variable is to adapt a **clustered bar chart** using the `barplot` function instead of the `countplot` function:\n```python\nax = sb.barplot(data = df, x = 'cat_var1', y = 'num_var2', hue = 'cat_var2')\nax.legend(loc = 8, ncol = 3, framealpha = 1, title = 'cat_var2')\n```",
              "instructor_notes": ""
            },
            {
              "id": 578256,
              "key": "a8ea2a67-86c9-446a-9d77-0fa5d24bc48e",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5abc973f_l5-c06-adaptations3/l5-c06-adaptations3.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/a8ea2a67-86c9-446a-9d77-0fa5d24bc48e",
              "caption": "",
              "alt": "",
              "width": 432,
              "height": 288,
              "instructor_notes": null
            },
            {
              "id": 578257,
              "key": "08978324-5102-4579-a86e-8d335cbf4b7e",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The \"hue\" parameter can also be used in a similar fashion in the `boxplot`, `violinplot`, and `pointplot` functions to add a categorical third variable to those plots in a clustered fashion. As a special note for `pointplot`, the default rendering aligns all levels of the \"hue\" categorical variable vertically. Use the \"dodge\" parameter to shift the levels in a clustered fashion:\n```python\nax = sb.pointplot(data = df, x = 'cat_var1', y = 'num_var2', hue = 'cat_var2',\n                  dodge = 0.3, linestyles = \"\")\n```",
              "instructor_notes": ""
            },
            {
              "id": 578258,
              "key": "7304f660-6367-492c-8a74-3df3ec731c03",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5abc9a2f_l5-c06-adaptations4/l5-c06-adaptations4.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/7304f660-6367-492c-8a74-3df3ec731c03",
              "caption": "",
              "alt": "",
              "width": 432,
              "height": 288,
              "instructor_notes": null
            },
            {
              "id": 578259,
              "key": "a59b43ee-269f-4836-bf67-37fa3870cd4e",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "As a final example, a **line plot** can be adapted from previous code showing how to create frequency polygons for levels of a categorical variable. In this case as well, we create a custom function to send to a **FacetGrid** object's `map` function that computes the means in each bin, then plots them as lines via `errorbar`.\n```python\ndef mean_poly(x, y, bins = 10, **kwargs):\n    \"\"\" Custom adapted line plot code. \"\"\"\n    # set bin edges if none or int specified\n    if type(bins) == int:\n        bins = np.linspace(x.min(), x.max(), bins+1)\n    bin_centers = (bin_edges[1:] + bin_edges[:-1]) / 2\n    \n    # compute counts\n    data_bins = pd.cut(x, bins, right = False,\n                       include_lowest = True)\n    means = y.groupby(data_bins).mean()\n    \n    # create plot\n    plt.errorbar(x = bin_centers, y = means, **kwargs)\n    \nbin_edges = np.arange(0.25, df['num_var1'].max()+0.5, 0.5)\ng = sb.FacetGrid(data = df, hue = 'cat_var2', size = 5)\ng.map(mean_poly, \"num_var1\", \"num_var2\", bins = bin_edges)\ng.set_ylabels('mean(num_var2)')\ng.add_legend()\n```",
              "instructor_notes": ""
            },
            {
              "id": 578260,
              "key": "0b691334-aacd-46c5-8f8c-60042bd5724f",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5abc9efd_l5-c06-adaptations5/l5-c06-adaptations5.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/0b691334-aacd-46c5-8f8c-60042bd5724f",
              "caption": "",
              "alt": "",
              "width": 436,
              "height": 360,
              "instructor_notes": null
            }
          ]
        },
        {
          "id": 572393,
          "key": "00a1adc5-a7b0-42ae-bb9e-adc667578945",
          "title": "Adapted Plot Practice",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "00a1adc5-a7b0-42ae-bb9e-adc667578945",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 593802,
              "key": "40f5e9b0-8755-4d1a-80d7-67b8965d95ea",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "viewdf5cb869",
              "pool_id": "jupyter",
              "view_id": "175c7e05-8969-40e7-ab47-db8b40dcaeae",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "ports": [],
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Adapted_Plot_Practice.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 572394,
          "key": "d0c00cb4-0d15-455e-8906-c838b653c84c",
          "title": "Plot Matrices",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "d0c00cb4-0d15-455e-8906-c838b653c84c",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 572395,
              "key": "83726949-eb6a-40f7-b622-470a1ee15f60",
              "title": "L5 081 Plot Matrices V3",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "2wY-euTIE5g",
                "china_cdn_id": "2wY-euTIE5g.mp4"
              }
            },
            {
              "id": 578229,
              "key": "8cd0ee78-80f7-447e-a089-57dd158fead7",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<hr>",
              "instructor_notes": ""
            },
            {
              "id": 572396,
              "key": "9f8f07ae-d176-4767-bd7d-d4071eea5007",
              "title": "DataVis L5C08 V2",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "fq-hakwfpZw",
                "china_cdn_id": "fq-hakwfpZw.mp4"
              }
            },
            {
              "id": 578228,
              "key": "6e3c93b3-a4dd-4abe-b234-dd71ee23fc9d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<hr>\n## Plot Matrices\n\nTo move back to bivariate exploration for a bit, you might come out of your initial univariate investigation of the data wanting to look at the relationship between many pairs of variables. Rather than generate these bivariate plots one by one, a preliminary option you might consider for exploration is the creation of a plot matrix. In a plot matrix, a matrix of plots is generated. Each row and column represents a different variable, and a subplot against those variables is generated in each plot matrix cell. This contrasts with faceting, where rows and columns will subset the data, and the same variables are depicted in each subplot.\n\nSeaborn's [**PairGrid**](https://seaborn.pydata.org/generated/seaborn.PairGrid.html) class facilitates the creation of this kind of plot matrix.\n```python\ng = sb.PairGrid(data = df, vars = ['num_var1', 'num_var2', 'num_var3'])\ng.map_diag(plt.hist)\ng.map_offdiag(plt.scatter)\n```\nBy default, **PairGrid** only expects to depict numeric variables; a typical invocation of **PairGrid** plots the same variables on the horizontal and vertical axes. On the diagonals, where the row and column variables match, a histogram is plotted. Off the diagonals, a scatterplot between the two variables is created.",
              "instructor_notes": ""
            },
            {
              "id": 578331,
              "key": "5c431031-9bb1-40aa-95b8-83599ae1f98a",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5abd22bb_l5-c08-plotmatrices1/l5-c08-plotmatrices1.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/5c431031-9bb1-40aa-95b8-83599ae1f98a",
              "caption": "",
              "alt": "",
              "width": 540,
              "height": 540,
              "instructor_notes": null
            },
            {
              "id": 578337,
              "key": "8399c6cb-c0b2-4838-bd86-61641673819f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "The [`pairplot`](https://seaborn.pydata.org/generated/seaborn.pairplot.html) function can also be used to render this common use case in a single call.\n\nFor other relationships, the flexibility of **PairGrid** shines. For example, if we want to look at the relationship between the numeric and categorical variables in the data, we need to set the different variable types on the rows and columns, then use an appropriate plot type for all matrix cells.\n\n```python\ng = sb.PairGrid(data = df, x_vars = ['num_var1', 'num_var2', 'num_var3'],\n                y_vars = ['cat_var1','cat_var2'])\ng.map(sb.violinplot, inner = 'quartile')\n```",
              "instructor_notes": ""
            },
            {
              "id": 578338,
              "key": "aa5a8315-f1e6-49c0-9d94-0a766019cd3a",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5abd25bb_l5-c08-plotmatrices2/l5-c08-plotmatrices2.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/aa5a8315-f1e6-49c0-9d94-0a766019cd3a",
              "caption": "",
              "alt": "",
              "width": 540,
              "height": 360,
              "instructor_notes": null
            },
            {
              "id": 578341,
              "key": "aa24410a-5085-4788-be3e-36d99b66c997",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "When you choose to create a plot matrix, be aware that the time it takes to render the plot depends on the number of data points you have and the number of variables you want to plot. Increasing the number of variables increases the number of plots that need to be rendered in a quadratic fashion. In addition, increasing the number of variables means that the individual subplot size needs to be reduced in order to fit the matrix width on your screen. That means that, if you have a lot of data, it might be difficult to see the relationships between variables due to overplotting, and it will take a long time to complete. One recommended approach is to take a random subset of the data to plot in the plot matrix instead. Use the plot matrix to identify interesting variable pairs, and then follow it up with individual plots on the full data.\n\n## Correlation Matrices\n\nFor numeric variables, it can be useful to create a correlation matrix as part of your exploration. While it's true that the [`.corr`](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.corr.html) function is perfectly fine for computing and returning a matrix of correlation coefficients, it's not too much trouble to plot the matrix as a heat map to make it easier to see the strength of the relationships.\n```python\nsb.heatmap(df.corr(), annot = True, fmt = '.2f', cmap = 'vlag_r', center = 0)\n```\nInstead of using the default sequential color map, a diverging color map is specified and its center is set to 0. That way, we can use hue to tell if a correlation is positive or negative, and see its strength from the hue's intensity.",
              "instructor_notes": ""
            },
            {
              "id": 578342,
              "key": "11848649-23b7-4e22-8ca6-8d205ee69b23",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5abd2d01_l5-c08-plotmatrices3/l5-c08-plotmatrices3.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/11848649-23b7-4e22-8ca6-8d205ee69b23",
              "caption": "",
              "alt": "",
              "width": 432,
              "height": 288,
              "instructor_notes": null
            },
            {
              "id": 578344,
              "key": "afc0967f-aaef-43b6-8fcb-edd07c6b34ca",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Don't forget that correlations are computed based on strength of linear relationship. Compare the correlation between \"num_var2\" and \"num_var3\" to the corresponding cell in the first plot matrix as an example of how a correlation statistic might be misleading.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 572397,
          "key": "653b4ea8-3c5a-4aa0-80bc-25f6d3aa5fa4",
          "title": "Feature Engineering",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "653b4ea8-3c5a-4aa0-80bc-25f6d3aa5fa4",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 572399,
              "key": "946b30aa-bc05-4c21-969a-6c2c3f6e2181",
              "title": "L5 091 Feature Engineering V2",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "jpMOSFMMga4",
                "china_cdn_id": "jpMOSFMMga4.mp4"
              }
            },
            {
              "id": 578226,
              "key": "f055ed4d-47c2-4d4c-9535-53c8f76fec11",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<hr>",
              "instructor_notes": ""
            },
            {
              "id": 572398,
              "key": "64fa4144-7f0b-456f-8d13-83640f5cd6a6",
              "title": "DataVis L5C09 V1",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "xlZ9AMV6VUE",
                "china_cdn_id": "xlZ9AMV6VUE.mp4"
              }
            },
            {
              "id": 578227,
              "key": "96e5aa87-1e5c-4814-bd8d-2d1c904d4b7f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "<hr>\n## Feature Engineering\n\nThis is not so much an additional technique for adding variables to your plot, but a reminder that feature engineering is a tool that you can leverage as you explore and learn about your data. As you explore a dataset, you might find that two variables are related in some way. Feature engineering is all about creating a new variable with a sum, difference, product, or ratio between those original variables that may lend a better insight into the research questions you seek to answer.\n\nFor example, if you have one variable that gives a count of crime incidents, and a second one that gives population totals, then you may want to engineer a new variable by dividing the former by the latter, obtaining an incident rate. This would account for a possible relationship between the original features where if there are more people, there might naturally be more chances for crimes to occur. If we looked at the raw counts rather than the incident rate, we risk just seeing information about population sizes rather than what we might really want.\n\nAnother way that you can perform feature engineering is to use the `cut` function to divide a numeric variable into ordered bins. When we split a numeric variable into ordinal bins, it opens it up to more visual encodings. For example, we might facet plots by bins of a numeric variable, or use discrete color bins rather than a continuous color scale. This kind of discretization step might help in storytelling by clearing up noise, allowing the reader to concentrate on major trends in the data. Of course, the bins might also mislead if they're spaced improperly – check out [this PolicyViz post](https://policyviz.com/2017/11/02/choosing-map-bins/) if you'd like to see a deeper discussion in the context of map-based visualizations.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 572400,
          "key": "bad3c411-ce3f-4220-8d20-bced53091138",
          "title": "How Much is Too Much?",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "bad3c411-ce3f-4220-8d20-bced53091138",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 578222,
              "key": "ec0911f3-52bd-4f04-a4b1-47f9a4ed6385",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## How Much is Too Much?\n\nBy now, you've seen a lot of ways of expanding the number of variables that can be depicted in a single visualization. The basic positional axes can handle two variables: one on the horizontal and one on the vertical. You can facet by both columns and rows to add up to two variables. Encodings in shape, size, and color could add as many as three more. However, you should try and resist the temptation to overuse your newfound power, and to instead practice some restraint in the number of variables that you include in any one plot.\n\nWhen you have only two variables plotted, A and B, you have only one relationship to understand. Add in a third variable C, and you have three pairwise relationships: A vs. B, A vs. C, and B vs. C. You also need to consider one interaction effect between all three variables: Does the value of C affect the relationship between A and B? With a fourth variable, you have six possible pairwise relationships and four different three-variable interaction effects. This exponential explosion of possible relationships with the number of variables means that there is a potential for cognitive overload if the data isn't conveyed clearly.\n\nThis is why it is so important to approach data exploration systematically, rather than just throw as many variables together as possible immediately. When you move from univariate visualizations to bivariate visualizations, you augment your previous understanding of individual distributions by seeing how they relate to one another. If you look at pairwise visualizations before putting together a trivariate plot, then you will have a clear view to how the interaction, if present, changes your previous understanding of the marginal pairwise relationship.\n\nWhen you move on to explanatory data visualizations, try to limit the number of variables that are introduced at the same time and make sure that the encoding choices convey the main findings to your reader in the clearest way possible. While it's good to keep a soft limit of about three or four variables in a single visualization, you can exceed this if the trends are clear or you introduce features to your reader in a systematic way.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 572401,
          "key": "59ef3627-b300-44c2-aeba-d04311e83650",
          "title": "Additional Plot Practice",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "59ef3627-b300-44c2-aeba-d04311e83650",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 593803,
              "key": "3027c738-9027-4ea6-9df1-0df8ea0419d7",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "viewdf5cb869",
              "pool_id": "jupyter",
              "view_id": "bfc93d14-917e-4037-a0f1-063933c5cdc3",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "ports": [],
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Additional_Plot_Practice.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 572402,
          "key": "ae2b83b6-1f61-4f72-a599-c8bd7ff9c207",
          "title": "Lesson Summary",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "ae2b83b6-1f61-4f72-a599-c8bd7ff9c207",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 572403,
              "key": "27c375c7-2e55-4c0b-8eea-92e31862a019",
              "title": "L5 121 Lesson Summary V1",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "SOBCduyymkQ",
                "china_cdn_id": "SOBCduyymkQ.mp4"
              }
            }
          ]
        }
      ]
    }
  },
  "_deprecated": [
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    }
  ]
}